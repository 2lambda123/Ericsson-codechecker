# -------------------------------------------------------------------------
#
#  Part of the CodeChecker project, under the Apache License v2.0 with
#  LLVM Exceptions. See LICENSE for license information.
#  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
#
# -------------------------------------------------------------------------
"""
"""


import json
import os
import re
import shlex
import subprocess

from codechecker_common.logger import get_logger

from codechecker_analyzer import host_check
from codechecker_analyzer import env

from .. import analyzer_base
from ..config_handler import CheckerState
from ..flag import has_flag
from ..flag import prepend_all
from ..clangsa.analyzer import ClangSA

from . import config_handler
from . import result_handler

LOG = get_logger('analyzer')


def parse_checkers(tidy_output):
    """
    Parse clang tidy checkers list.
    Skip clang static analyzer checkers.
    Store them to checkers.
    """
    checkers = []
    pattern = re.compile(r'^\S+$')
    for line in tidy_output.splitlines():
        line = line.strip()
        if line.startswith('Enabled checks:') or line == '':
            continue
        elif line.startswith('clang-analyzer-'):
            continue
        match = pattern.match(line)
        if match:
            checkers.append((match.group(0), ''))
    return checkers


def parse_checker_config(config_dump):
    """
    Return the parsed clang-tidy config options as a list of
    (flag, default_value) tuples.
    config_dump -- clang-tidy config options YAML dump.
    """
    reg = re.compile(r'key:\s+(\S+)\s+value:\s+([^\n]+)')
    return re.findall(reg, config_dump)


def parse_analyzer_config(config_dump):
    """
    Return the parsed clang-tidy analyzer options as a list of
    (flag, default_value) tuples.
    config_dump -- clang-tidy config options YAML dump.
    """
    return re.findall(r'^(\S+):\s+(\S+)$', config_dump, re.MULTILINE)


class ClangTidy(analyzer_base.SourceAnalyzer):
    """
    Constructs the clang tidy analyzer commands.
    """

    ANALYZER_NAME = 'clang-tidy'

    def add_checker_config(self, checker_cfg):
        LOG.error("Not implemented yet")

    @classmethod
    def get_analyzer_checkers(cls, cfg_handler, environ):
        """
        Return the list of the supported checkers.
        """
        try:
            result = subprocess.check_output(
                [cfg_handler.analyzer_binary, "-list-checks", "-checks=*"],
                env=environ,
                universal_newlines=True,
                encoding="utf-8",
                errors="ignore")
            return parse_checkers(result)
        except (subprocess.CalledProcessError, OSError):
            return []

    @classmethod
    def get_checker_config(cls, cfg_handler, environ):
        try:
            result = subprocess.check_output(
                [cfg_handler.analyzer_binary, "-dump-config"],
                env=environ,
                universal_newlines=True,
                encoding="utf-8",
                errors="ignore")
            return parse_checker_config(result)
        except (subprocess.CalledProcessError, OSError):
            return []

    @classmethod
    def get_analyzer_config(cls, cfg_handler, environ):
        try:
            result = subprocess.check_output(
                [cfg_handler.analyzer_binary, "-dump-config"],
                env=environ,
                universal_newlines=True,
                encoding="utf-8",
                errors="ignore")
            return parse_analyzer_config(result)
        except (subprocess.CalledProcessError, OSError):
            return []

    def construct_analyzer_cmd(self, result_handler):
        """
        """
        try:
            config = self.config_handler

            analyzer_cmd = [config.analyzer_binary]

            # Do not disable any clang-tidy checks explicitly, but don't run
            # ClangSA checkers. ClangSA checkers are driven by an other
            # analyzer in CodeChecker.
            # For clang compiler warnings a correspoding
            # clang-diagnostic error is generated by Clang tidy.
            # They can be disabled by this glob -clang-diagnostic-*
            checkers_cmdline = ['-clang-analyzer-*', 'clang-diagnostic-*']

            compiler_warnings = []

            # Config handler stores which checkers are enabled or disabled.
            for checker_name, value in config.checks().items():
                state, _ = value

                # Checker name is a compiler warning.
                if checker_name.startswith('W'):
                    warning_name = checker_name[4:] if \
                        checker_name.startswith('Wno-') else checker_name[1:]

                    if state == CheckerState.enabled:
                        compiler_warnings.append('-W' + warning_name)
                    elif state == CheckerState.disabled:
                        compiler_warnings.append('-Wno-' + warning_name)

                    continue

                if state == CheckerState.enabled:
                    checkers_cmdline.append(checker_name)
                elif state == CheckerState.disabled:
                    checkers_cmdline.append('-' + checker_name)

            # The invocation should end in a Popen call with shell=False, so
            # no globbing should occur even if the checks argument contains
            # characters that would trigger globbing in the shell.
            analyzer_cmd.append("-checks=%s" % ','.join(checkers_cmdline))

            analyzer_cmd.extend(config.analyzer_extra_arguments)

            if config.checker_config and config.checker_config != '{}':
                analyzer_cmd.append("-config=" + config.checker_config)

            analyzer_cmd.append(self.source_file)

            analyzer_cmd.append("--")

            analyzer_cmd.append('-Qunused-arguments')

            # Enable these compiler warnings by default.
            analyzer_cmd.extend(['-Wall', '-Wextra'])

            compile_lang = self.buildaction.lang

            if not has_flag('-x', analyzer_cmd):
                analyzer_cmd.extend(['-x', compile_lang])

            if not has_flag('--target', analyzer_cmd) and \
                    self.buildaction.target.get(compile_lang, "") != "":
                analyzer_cmd.append(
                    "--target=" + self.buildaction.target.get(compile_lang,
                                                              ""))

            analyzer_cmd.extend(self.buildaction.analyzer_options)

            analyzer_cmd.extend(prepend_all(
                '-isystem',
                self.buildaction.compiler_includes[compile_lang]))

            if not has_flag('-std', analyzer_cmd) and not \
                    has_flag('--std', analyzer_cmd):
                analyzer_cmd.append(
                    self.buildaction.compiler_standard.get(compile_lang, ""))

            analyzer_cmd.extend(compiler_warnings)

            return analyzer_cmd

        except Exception as ex:
            LOG.error(ex)
            return []

    def get_analyzer_mentioned_files(self, output):
        """
        Parse Clang-Tidy's output to generate a list of files that were
        mentioned in the standard output or standard error.
        """

        if not output:
            return set()

        # A line mentioning a file in Clang-Tidy's output looks like this:
        # /home/.../.cpp:L:C: warning: foobar.
        regex = re.compile(
            # File path followed by a ':'.
            r'^(?P<path>[\S ]+?):'
            # Line number followed by a ':'.
            r'(?P<line>\d+?):'
            # Column number followed by a ':' and a space.
            r'(?P<column>\d+?): ')

        paths = []

        for line in output.splitlines():
            match = re.match(regex, line)
            if match:
                paths.append(match.group('path'))

        return set(paths)

    @classmethod
    def resolve_missing_binary(cls, configured_binary, environ):
        """
        In case of the configured binary for the analyzer is not found in the
        PATH, this method is used to find a callable binary.
        """

        LOG.debug("%s not found in path for ClangTidy!", configured_binary)

        if os.path.isabs(configured_binary):
            # Do not autoresolve if the path is an absolute path as there
            # is nothing we could auto-resolve that way.
            return False

        # clang-tidy, clang-tidy-5.0, ...
        clangtidy = env.get_binary_in_path(['clang-tidy'],
                                           r'^clang-tidy(-\d+(\.\d+){0,2})?$',
                                           environ)

        if clangtidy:
            LOG.debug("Using '%s' for Clang-tidy!", clangtidy)
        return clangtidy

    def construct_result_handler(self, buildaction, report_output,
                                 severity_map, skiplist_handler):
        """
        See base class for docs.
        """
        report_hash = self.config_handler.report_hash
        res_handler = result_handler.ClangTidyPlistToFile(buildaction,
                                                          report_output,
                                                          report_hash)

        res_handler.severity_map = severity_map
        res_handler.skiplist_handler = skiplist_handler
        return res_handler

    @classmethod
    def construct_config_handler(cls, args, context):
        handler = config_handler.ClangTidyConfigHandler()
        handler.analyzer_binary = context.analyzer_binaries.get(
            cls.ANALYZER_NAME)
        handler.report_hash = args.report_hash \
            if 'report_hash' in args else None

        # FIXME We cannot get the resource dir from the clang-tidy binary,
        # therefore we get a sibling clang binary which of clang-tidy.
        # TODO Support "clang-tidy -print-resource-dir" .
        check_env = env.extend(context.path_env_extra,
                               context.ld_lib_path_extra)
        # Overwrite PATH to contain only the parent of the clang binary.
        if os.path.isabs(handler.analyzer_binary):
            check_env['PATH'] = os.path.dirname(handler.analyzer_binary)
        clang_bin = ClangSA.resolve_missing_binary('clang',
                                                   check_env)
        handler.compiler_resource_dir = \
            host_check.get_resource_dir(clang_bin, context)

        try:
            with open(args.tidy_args_cfg_file, 'r', encoding='utf-8',
                      errors='ignore') as tidy_cfg:
                handler.analyzer_extra_arguments = \
                    re.sub(r'\$\((.*?)\)', env.replace_env_var,
                           tidy_cfg.read().strip())
                handler.analyzer_extra_arguments = \
                    shlex.split(handler.analyzer_extra_arguments)
        except IOError as ioerr:
            LOG.debug_analyzer(ioerr)
        except AttributeError as aerr:
            # No clang tidy arguments file was given in the command line.
            LOG.debug_analyzer(aerr)

        analyzer_config = {}
        # TODO: This extra "isinsrance" check is needed for
        # CodeChecker analyzers --analyzer-config. This command also
        # runs this function in order to construct a config handler.
        if 'analyzer_config' in args and \
                isinstance(args.analyzer_config, list):
            r = re.compile(r'(?P<analyzer>.+?):(?P<key>.+?)=(?P<value>.+)')
            for cfg in args.analyzer_config:
                m = re.search(r, cfg)
                if m.group('analyzer') == cls.ANALYZER_NAME:
                    analyzer_config[m.group('key')] = m.group('value')

        # TODO: This extra "isinsrance" check is needed for
        # CodeChecker checkers --checker-config. This command also
        # runs this function in order to construct a config handler.
        if 'checker_config' in args and \
                isinstance(args.checker_config, list):
            r = re.compile(r'(?P<analyzer>.+?):(?P<key>.+?)=(?P<value>.+)')
            check_options = []

            for cfg in args.checker_config:
                m = re.search(r, cfg)
                if m.group('analyzer') == cls.ANALYZER_NAME:
                    check_options.append({'key': m.group('key'),
                                          'value': m.group('value')})
            analyzer_config['CheckOptions'] = check_options
        else:
            try:
                with open(args.tidy_config, 'r',
                          encoding='utf-8', errors='ignore') as tidy_config:
                    handler.checker_config = tidy_config.read()
            except IOError as ioerr:
                LOG.debug_analyzer(ioerr)
            except AttributeError as aerr:
                # No clang tidy config file was given in the command line.
                LOG.debug_analyzer(aerr)

        # 'take-config-from-directory' is a special option which let the user
        # to use the '.clang-tidy' config files. It will disable analyzer and
        # checker configuration options.
        if not handler.checker_config and \
                analyzer_config.get('take-config-from-directory') != 'true':
            handler.checker_config = json.dumps(analyzer_config)

        check_env = env.extend(context.path_env_extra,
                               context.ld_lib_path_extra)

        checkers = ClangTidy.get_analyzer_checkers(handler, check_env)

        # Read clang-tidy checkers from the config file.
        clang_tidy_checkers = context.checker_config.get(cls.ANALYZER_NAME +
                                                         '_checkers')

        try:
            cmdline_checkers = args.ordered_checkers
        except AttributeError:
            LOG.debug_analyzer('No checkers were defined in '
                               'the command line for %s',
                               cls.ANALYZER_NAME)
            cmdline_checkers = None

        handler.initialize_checkers(
            context.available_profiles,
            context.package_root,
            checkers,
            clang_tidy_checkers,
            cmdline_checkers,
            'enable_all' in args and args.enable_all)

        return handler
