# -------------------------------------------------------------------------
#                     The CodeChecker Infrastructure
#   This file is distributed under the University of Illinois Open Source
#   License. See LICENSE.TXT for details.
# -------------------------------------------------------------------------
"""
Defines the CodeChecker action for parsing a set of analysis results into a
human-readable format.
"""

import argparse
import json
import os

from libcodechecker import generic_package_context
from libcodechecker import generic_package_suppress_handler
from libcodechecker import util
from libcodechecker.analyze.analyzers import analyzer_types
# TODO: This is a cross-subpackage reference...
from libcodechecker.log import build_action
from libcodechecker.logger import add_verbose_arguments
from libcodechecker.logger import LoggerFactory

LOG = LoggerFactory.get_new_logger('PARSE')


def get_argparser_ctor_args():
    """
    This method returns a dict containing the kwargs for constructing an
    argparse.ArgumentParser (either directly or as a subparser).
    """

    return {
        'prog': 'CodeChecker parse',
        'formatter_class': argparse.ArgumentDefaultsHelpFormatter,

        # Description is shown when the command's help is queried directly
        'description': "Parse and pretty-print the summary and results from "
                       "one or more 'codechecker-analyze' result files.",

        # Help is shown when the "parent" CodeChecker command lists the
        # individual subcommands.
        'help': "Print analysis summary and results in a human-readable "
                "format."
    }


def add_arguments_to_parser(parser):
    """
    Add the subcommand's arguments to the given argparse.ArgumentParser.
    """

    parser.add_argument('input',
                        type=str,
                        nargs='*',
                        metavar='file/folder',
                        default=os.path.join(util.get_default_workspace(),
                                             'reports'),
                        help="The analysis result files and/or folders "
                             "containing analysis results which should be "
                             "parsed and printed.")

    parser.add_argument('-t', '--type', '--input-format',
                        dest="input_format",
                        required=False,
                        choices=['plist'],
                        default='plist',
                        help="Specify the format the analysis results were "
                             "created as.")

    parser.add_argument('--suppress',
                        type=str,
                        dest="suppress",
                        default=argparse.SUPPRESS,
                        required=False,
                        help="Path of the suppress file to use. Records in "
                             "the suppress file are used to suppress the "
                             "display of certain results when parsing the "
                             "analyses' report. (Reports to an analysis "
                             "result can also be suppressed in the source "
                             "code -- please consult the manual on how to "
                             "do so.) NOTE: The suppress file relies on the "
                             "\"bug identifier\" generated by the analyzers "
                             "which is experimental, take care when relying "
                             "on it.")

    parser.add_argument('--print-steps',
                        dest="print_steps",
                        action="store_true",
                        required=False,
                        help="Print the steps the analyzers took in finding "
                             "the reported defect.")

    add_verbose_arguments(parser)
    parser.set_defaults(func=main)


def parse(f, context, metadata_dict, suppress_handler, steps):
    """
    Prints the results in the given file to the standard output in a human-
    readable format.
    """

    if not f.endswith(".plist"):
        LOG.info("Skipping input file '" + f + "' as it is not a plist.")
        return

    LOG.debug("Parsing input file '" + f + "'")

    buildaction = build_action.BuildAction()
    if os.path.basename(f).startswith("clangsa_"):
        buildaction.analyzer_type = analyzer_types.CLANG_SA
    elif os.path.basename(f).startswith("clang-tidy_"):
        buildaction.analyzer_type = analyzer_types.CLANG_TIDY

    rh = analyzer_types.construct_parse_handler(buildaction,
                                                f,
                                                context.severity_map,
                                                suppress_handler,
                                                steps)

    # Set some variables of the result handler to use the saved file.
    rh.analyzer_returncode = 0
    rh.result_file = f
    rh.analyzer_cmd = ""

    rh.analyzed_source_file = "UNKNOWN"
    base_f = os.path.basename(f)
    if 'result_source_files' in metadata_dict and \
            base_f in metadata_dict['result_source_files']:
        rh.analyzed_source_file = \
            metadata_dict['result_source_files'][base_f]

    rh.handle_results()


def main(args):
    """
    Entry point for parsing some analysis results and printing them to the
    stdout in a human-readable format.
    """

    context = generic_package_context.get_context()

    # To ensure the help message prints the default folder properly,
    # the 'default' for 'args.input' is a string, not a list.
    # But we need lists for the foreach here to work.
    if isinstance(args.input, str):
        args.input = [args.input]

    original_cwd = os.getcwd()

    suppress_handler = None
    if 'suppress' in args:
        if not os.path.isfile(args.suppress):
            LOG.warning("Suppress file '" + args.suppress + "' given, but it "
                        "does not exist -- will not suppress anything.")
        else:
            suppress_handler = generic_package_suppress_handler.\
                GenericSuppressHandler(args.suppress)

    for input_path in args.input:
        os.chdir(original_cwd)
        LOG.debug("Parsing input argument: '" + input_path + "'")

        if os.path.isfile(input_path):
            parse(input_path, context, {}, suppress_handler, args.print_steps)
        elif os.path.isdir(input_path):
            metadata_file = os.path.join(input_path, "metadata.json")
            metadata_dict = {}
            if os.path.exists(metadata_file):
                with open(metadata_file, 'r') as metadata:
                    metadata_dict = json.load(metadata)
                    LOG.debug(metadata_dict)

                if 'working_directory' in metadata_dict:
                    os.chdir(metadata_dict['working_directory'])

            _, _, files = next(os.walk(input_path), ([], [], []))
            for f in files:
                parse(os.path.join(input_path, f), context, metadata_dict,
                      suppress_handler, args.print_steps)

    os.chdir(original_cwd)
